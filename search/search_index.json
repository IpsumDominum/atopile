{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"code to electronics","text":"<p>Welcome to atopile - code to electronics</p>"},{"location":"building/","title":"Building your ato project","text":""},{"location":"building/#building-predefined-entry-points","title":"Building predefined entry points","text":"<p>The <code>ato.yaml</code> file can contain predefined build configurations. Those can be defined like so:</p> <p>ato.yml</p> <pre><code>...\nbuilds:\n    default:\n        entry: elec/src/your-project.ato:YourModule\n    build-2:\n        entry: elec/src/your-second-project.ato:YourSecondModule\n...\n</code></pre> <p>The <code>ato build</code> command will build the atopile modules for all of those entry points.</p> <p>For a specific build, you can use the -b or --build option like so: <pre><code>ato build -b build-name\n</code></pre> or <pre><code>ato build --build build-name\n</code></pre></p>"},{"location":"building/#building-a-given-entry-point","title":"Building a given entry point","text":"<p>A given entry point can be built like so from your atopile project directory:</p> <pre><code>ato build elec/src/your-project.ato:YourModule\n</code></pre>"},{"location":"building/#building-given-targets","title":"Building given targets","text":"<p>Those are the targets that can currently be built by atopile:</p> <ul> <li>Netlist (\"netlist\")</li> <li>Bill Of Material (\"bom\")</li> <li>Designator Map (\"designator-map\")</li> <li>Manufacturing Data (\"mfg-data\")</li> <li>Consolidate footprint (\"copy-footprints\")</li> <li>All of the above (\"all\")</li> </ul> <p>The target can be specified with the <code>-t</code> or <code>--target</code> like so:</p> <p><pre><code>ato build -t target-name\n</code></pre> or <pre><code>ato build --target target-name\n</code></pre></p>"},{"location":"ci/","title":"Generation of build outputs","text":"<p>Continuous integration / continuous distribution (CI/CD) is a powerful process to automatically export and deploy your project to production.</p>"},{"location":"ci/#continuous-integration-continuous-distribution","title":"Continuous integration / continuous distribution","text":"<p>Our CI pipeline will automatically generate the following outputs for you:</p> <ul> <li>Gerbers (with githash automatically stamped on it!)</li> <li>BOM</li> <li>Pick and place file</li> </ul> <p>Our template project has an example of a GitHub actions workflow.</p>"},{"location":"ci/#github-actions-artifacts","title":"GitHub actions artifacts","text":"<p>To download the artifacts, go to the github action page, find the pipeline with the commit you are interested in and download the build artifacts from it.</p>"},{"location":"class/","title":"Class, subclass and replace","text":""},{"location":"class/#class-and-subclass","title":"Class and subclass","text":"<p>Like classes in most modern languages, we can subclass and inherit from blocks.</p> <pre><code>module SomeModule:\n    signal some_signal\n    signal gnd\n    some_variable = \"some value\"\n\nmodule SubclassedModule from SomeModule:\n    # inherits all the signals and variables from SomeModule\n    # we don't need to declare the signals again,\n    # but we will replace the value of some_variable\n    some_variable = \"some other value\"\n\nmodule Test:\n    signal gnd\n    # creates an instance of the SubclassedModule\n    subclased_module = new SubclassedModule\n    # connects the some_signal of the SubclassedModule to the gnd of Test\n    subclased_module.gnd ~ gnd\n</code></pre> <p>note: we can subclass a module as a component, but not the other way around. A component is expected to represent a specific component.</p> <p>This subclassing is also useful for creating typed interfaces:</p> <pre><code>interface I2C:\n    signal sda\n    signal scl\n\nmodule SomeModule:\n    i2c = new I2C\n\nmodule Test:\n    a = new SomeModule\n    b = new SomeModule\n    a.i2c ~ b.i2c  # connects both sda and scl in one fell swoop\n</code></pre>"},{"location":"class/#-the-replace-operator","title":"<code>-&gt;</code> the replace operator","text":"<p>This operator allows you to increase the specificity of a block somewhere.</p> <p>Take the following example: 1. You want to create a reusable half-bridge module 2. If you spec the FETs within the module, you can't readily reuse the design in other projects with other FETs 3. If you don't declare the FETs at the bottom level it's a PITA to use, since every time you use it you need to remember to slot the FET in the right spot</p> <p>You want some way to say \"we're putting a FET here, but we'll tell you which FET later\"</p> <p>Subclassing is the way you say what a FET is, the replacement operator gives you the later.</p> <pre><code>module NFET:\n    signal gate\n    signal source\n    signal drain\n\nmodule HalfBridge:\n    signal high\n    signal low\n    signal output\n    signal high_gate\n    signal low_gate\n\n    high_fet = new NFET\n    low_fet = new NFET\n\n    # let's pretend we do something useful here like hook it all up\n\n# some time later... perhaps in another file\n\ncomponent SomeNFET from NFET:\n    footprint = \"TO-220-3_Vertical\"\n    # this isn't a legit package, but you get the idea\n\nmodule MotorController:\n    a = new HalfBridge\n    # ...\n    # replace the fets with a SomeNFET\n    a.high_fet -&gt; SomeNFET\n    a.low_fet -&gt; SomeNFET\n</code></pre>"},{"location":"config/","title":"Project configuration","text":""},{"location":"config/#versioning","title":"Versioning","text":"<p>Versions within atopile follow the semantic versioning 2.x schema. See https://semver.org for details Semantic versions may be prefixed with a \"v\", so <code>v1.0.0 == 1.0.0</code></p>"},{"location":"config/#atoyaml-project-config","title":"<code>ato.yaml</code> project config","text":"<p>The <code>ato.yaml</code> is significant indicator for a project:</p> <ol> <li>It marks the root of a project. The <code>ato</code> commands in the CLI is largely dependant upon the <code>ato.yaml</code> to know what project you're referring to.</li> <li>It contains project-level configuration information like where to build from, which layouts have what entry-points</li> <li>Lists project dependencies and the required versions of those dependencies</li> <li>Specifies what compiler version the project is intended to build with</li> </ol>"},{"location":"config/#dependencies","title":"Dependencies","text":"<p>Each package listed under the <code>dependencies:</code> key is automatically downloaded and installed for users when they run the <code>ato install</code> command from within a project. These dependencies are anticipated to make the project run.</p> <p>Each dependency may have constraints on its version using the following operators:</p> <p>Assuming dependency says <code>my-package &lt;operator&gt;1.2.3</code> the following table describes whether each of the operators would match.</p> <p>They're in approximate order of usefulness/recommendation</p> Op <code>0.1.1</code> <code>1.1.0</code> <code>1.2.3</code> <code>1.2.4</code> <code>1.3.0</code> <code>1.4.0</code> <code>2.0.0</code> Description <code>^</code> \u2714 \u2714 \u2714 \u2714 &gt;=, up to the next major <code>~</code> \u2714 \u2714 &gt;=, up to the next minor <code>==</code> \u2714 Exactly <code>*</code> \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 Any <code>!</code> \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 Not (usually used in combination with others) <p><code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code> all work, but have niche value. If you need to use them, something's probably broken.</p>"},{"location":"config/#compiler-version","title":"Compiler version","text":"<p>eg. <code>ato-version: v0.1.8</code></p> <p>The installed compiler is matched against this value to see if the project is buildable in the current environment.</p> <p>It's matched using either: - <code>~</code> if the installed compiler version <code>&lt;1.0.0</code> - else <code>^</code> (up to the next major)</p> <p>Practically, this means breaking compiler changes are indicated using the minor (eg. <code>0.1.0</code>, <code>0.2.0</code>, <code>0.3.0</code>, <code>0.4.0</code>) until version <code>1.0.0</code>.</p> <p>When you upgrade your compiler with breaking changes, you need to update your project to match the language changes, bumping this version in your project's <code>ato.yaml</code> file</p>"},{"location":"doc-strings/","title":"Doc-strings","text":"<p>Doc-strings should be used to add in-code documentation of modules.</p> <p>eg. <pre><code>module MyModule:\n    \"\"\"\n    This is a hiiiiigh quality module!\n    \"\"\"\n</code></pre></p> <p>This documentation not only helps you remember what you did, but also means your package is searchable and useable by others.</p>"},{"location":"first_project/","title":"Creating an ato project","text":""},{"location":"first_project/#project-structure-setup","title":"Project structure setup","text":""},{"location":"first_project/#with-ato-create-recommended","title":"With <code>ato create</code> recommended","text":"<p>To create a project, you can run the command</p> <pre><code>ato create\n</code></pre> <p>This command will start by asking for a name to your project. It will then clone the project template on github. Once created on github, paste the url of your repository into the command line. Your project should be up and running!</p> <p>We also add a firmware and mech folder so you can store and 3D designs or firmware that is associated to your project. Verison controlling everyhting under the same project can be quite handy.</p>"},{"location":"first_project/#manually","title":"Manually","text":"<p>You can create your own project instead of using ato create. Perhaps you will want to setup the project and for it as you create your ato projects. Make sure to follow this project structure:</p> <pre><code>.\n\u251c\u2500\u2500 venv -&gt; (active) virtual environmenent with python^3.11 and atopile installed\n\u2514\u2500\u2500 your-project\n    \u251c\u2500\u2500 ato.yaml --&gt; definition file for your atopile project\n    \u251c\u2500\u2500 elec --&gt; your virtual environment\n    \u2502    \u251c\u2500\u2500 src\n    \u2502    \u251c\u2500\u2500 src\n    \u2502    \u2502   \u251c\u2500\u2500 file.ato\n    \u2502    \u2514\u2500\u2500 layout\n    \u2502        \u2514\u2500\u2500 default\n    \u2502            \u251c\u2500\u2500 kicad-project.kicad_pro\n    \u2502            \u251c\u2500\u2500 kicad-project.kicad_pcb\n    \u2502            \u251c\u2500\u2500 kicad-project.kicad_sch\n    \u2502            \u2514\u2500\u2500 fp-lib-table\n    \u2514\u2500\u2500 ci/cd file --&gt; useful for running jobs automatically on your repo\n</code></pre> <p>Tip</p> <p>Our template project contains example code for a github CI workflow to compile your ato files and access your manufacturing files from kicad. Find it here.</p>"},{"location":"first_project/#atoyaml-setup","title":"<code>ato.yaml</code> setup","text":"<p>The root of an ato project is marked by the presence of an <code>ato.yaml</code> file.</p> <p><code>ato.yaml</code> contains some project configuration information like the list of things you want to build. It's similar in concept to a package.json in js/node/npm land.</p> <p>Here's an example:</p> <pre><code># this line defines the version of compiler required to compile the project\nato-version: ^0.0.18\n# those lines define the elements that will be built by the compiler\nbuilds:\n  default:\n    entry: elec/src/your-project.ato:YourProject\n# The compiler version follows sementic versioning. The required version to compile your project can be specified using npm's standard.\n\n# Those lines define the package dependencies that your project might have. You can specify the exact version of the package you want using semantic versioning.\ndependencies:\n- generics^v1.0.0\n</code></pre> <p>Tip</p> <p>The compiler version follows sementic versioning. The required version to compile your project can be specified using npm's standard. The same applies to your dependencies.</p>"},{"location":"first_project/#bulding-the-project","title":"Bulding the project","text":"<p>To test that your project is building, run:</p> <p><code>ato build</code></p> <p>Tip</p> <p><code>ato build</code> will build the default module and kicad layout. You can specify a specific target with:</p> <p><code>ato build --build [name_of_your_build]</code></p> <p>The build name is defined in the <code>ato.yaml</code> file.</p> <p>You should see a build directory appear in your project structure. This is where atopile places the output files generated from compilation.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p><code>atopile</code> brings the best of software development to the world of hardware design.</p> <p>We're starting with an electronics compiler and a new language called <code>ato</code>. Files with the <code>.ato</code> extension can be used to describe your circuit, and compiles it to netlists that can be laid out and fabricated.</p> <p>The <code>.ato</code> files are human readable and can be version controlled, so you can collaborate with your team on the design of your hardware. They're modular, so you can reuse components from other projects, and share them with the community. They provide a way to save the intelligence of your design and the validation required to make sure it works as intended, so you can be confident that your design will work as expected.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>To run atopile, you will need the atopile compiler, the VSCode extension for synthax highlighting and git credential manager.</p>"},{"location":"getting-started/#atopile-compiler-with-pip-recommended","title":"atopile compiler - with pip recommended","text":"<p>atopile is published as a python package on pypi. You can install it using <code>pip</code> from your command line. We recommend setting up a virtual environment for atopile so that atopile's dependencies don't calsh with the rest of your system.</p> <p>Start by making sure you have <code>python@3.11</code> or later installed on your machine.</p> How to install python 3.11 or later <p>To install python 3.11 or later, you can use brew</p> <p><code>brew install python@3.11</code></p> <p>once you create your venv, make sure to run:</p> <p><code>python3.11 -m venv venv</code></p> <p>Setup the venv: <pre><code>python3.11 -m venv venv\n</code></pre> Activate the venv: <pre><code>source venv/bin/activate\n</code></pre></p> <p>Now you can install atopile: <pre><code>pip install atopile\n</code></pre></p> <p>atopile should be installed. You can verify that it worked with the following command which should give you the current version of atopile. <pre><code>ato --version\n</code></pre></p> <p> Getting started with atopile - get setup and build your first project from scratch \u2013  32m \u2013 We have a video of how to install atopile and setup your project here.</p>"},{"location":"getting-started/#atopile-compiler-with-git","title":"atopile compiler - with git","text":"<p>atopile can be directly installed from GitHub by cloning the repository into a subfolder of your project root. This could be useful if you want to use the latest version of atopile:</p> <p><pre><code>git clone https://github.com/atopile/atopile.git\n</code></pre> This will create a repository with the latest version of atopile. You can install it using pip:</p> <pre><code>pip install -e atopile\n</code></pre>"},{"location":"getting-started/#vscode-extension-extension-store","title":"VSCode extension - extension store","text":"<p>We recomend using VSCode to run atopile as it will provide synthax highlighting.</p> <p>From VSCode, navigate to the VSCode extensions and install atopile.</p> <p></p>"},{"location":"getting-started/#making-a-simple-circuit","title":"Making a simple circuit","text":"<p>To get you started quickly, here is an example of a simple atopile circuit. See the rest of the documentation on how to fully use the atopile language features.</p> <p>Let's build a voltage divider. Start by invoking <code>ato create</code> to create a new project.</p> <p>Once created, open elec/src/your-project.ato and modify it in the following way:</p> your-project.ato <pre><code>import Resistor from \"generics/resistors.ato\"\n\nmodule YourModule:\n    signal top\n    signal out\n    signal bottom\n\n    r_top = new Resistor\n    r_top.footprint = \"R0402\"\n    r_bottom = new Resistor\n    r_bottom.footprint = \"R0402\"\n\n    top ~ r_top.p1; r_top.p2 ~ out\n    out ~ r_bottom.p1; r_bottom.p2 ~ bottom\n</code></pre> <p>Now you can built this project and get a voltage divider!</p> <p>Tip</p> <p>The generics library should be installed by default in <code>your-project/.ato/modules/generics</code> directory. If not, run <code>ato install generics</code></p>"},{"location":"git/","title":"Version control using git","text":"<p>git is a powerful way to version control your design and one of the key reason we started atopile. If you don't know about git, we strongly recommend learning it. There is a high chance you will end up loving it.</p>"},{"location":"git/#get-stuff-from-the-server-sync","title":"Get stuff from the server / sync","text":"<p>git fetch origin  git pull"},{"location":"git/#make-a-new-branch","title":"Make a new branch","text":"<p><code>git checkout -b &lt;branch-name&gt;</code></p> <p><code>git checkout -b &lt;branch-name&gt; &lt;from-branch&gt;</code></p> <p>eg. <code>git checkout -b mawildoer/new-feature origin/main</code></p>"},{"location":"git/#save-some-work","title":"Save some work","text":"<p>1.</p> <p><code>git add &lt;whatever-you-wanna-save&gt;</code></p> <p><code>git add .</code>  -- save everything I've changed (including perhaps things we forgot to <code>.gitignore</code>)</p> <p>2.</p> <p><code>git commit</code></p> <p><code>git commit -m \"&lt;message-here&gt;\"</code></p>"},{"location":"git/#push-it-back-for-everyone-else","title":"Push it back for everyone else","text":"<p><code>git push</code> works if you didn't spec a \"from\" branch in <code>git checkout -b ...</code></p> <p><code>git push -u origin HEAD</code> always works</p> <p>Will respond with a way to make a branch:</p> <pre><code>remote:\nremote: To create a merge request for mawildoer/dummy-branch, visit:\nremote:   https://gitlab.atopile.io/atopile/servo-drive/-/merge_requests/new?merge_request%5Bsource_branch%5D=mawildoer%2Fdummy-branch\nremote:\nTo gitlab.atopile.io:atopile/servo-drive.git\n</code></pre> <p>Cmd+ on the link to gitlab"},{"location":"import/","title":"Imports","text":"<p>You can import assets by specifying what you want to import and where you want to import it from using the following syntax within your <code>.ato</code> files:</p> <p><code>import What from \"where.ato\"</code></p> <p>Notes on that statement: - add quotes on the \"where.ato\" - it's a string - <code>What</code> is capitalised - it's a type and types should be capitalised, though this isn't enforced and you can import things other than types from other files</p> <p>The import statements are with respect to the current project, or within the standard library (<code>.ato/modules/</code>)</p>"},{"location":"install/","title":"Packages and component installation","text":""},{"location":"install/#components","title":"Components","text":""},{"location":"install/#installing-components-from-jlcpcb","title":"Installing components from JLCPCB","text":"<p>Here is an example on how to install the RP2040 chip from JLCPCB:</p> <p><code>ato install --jlcpcb C2040</code></p> <p>The command will add your footprint and 3D representation to the KiCAD library (named lib in your folder structure) and create an ato file of the component in the elec/src directory.</p>"},{"location":"install/#adding-components-manually","title":"Adding components manually","text":"<p>To manually add components, follow the instructions for creating a component in the type section.</p>"},{"location":"install/#packages","title":"Packages","text":""},{"location":"install/#browsing-packages","title":"Browsing packages","text":"<p>The atopile package registry contains a list of existing ato packages. Packages usually contain components, modules footprints and layout that can be reused in other projects.</p> <p>A package usually points to a git repository that contains the design files, in a similar fashion to a standard atopile project.</p> <p>See an example of a package with the generics library.</p>"},{"location":"install/#installing-packages","title":"Installing packages","text":"<p>To install a package, run the following command:</p> <p><code>ato install &lt;your-package-name&gt;</code></p> <p>The package will be added in the .ato/modules/your-package-name directory. It's installed just like existing git repositories that means you can make changes to it and push those changes back to the remote, if you have permissions to do so.</p>"},{"location":"install/#upgrading-packages-version-management","title":"Upgrading packages &amp; version management","text":"<p>You can pull the latest packages by running:</p> <p><code>ato install --upgrade</code></p> <p>This will pull the latest tag version for the packages. If you wish to further specify which version of the package you'd like to install, you can use sementic versioning in the <code>ato.yaml</code> file. For example, you can request the highest available version of the generics package 1.x.x:</p> <p>ato.yml</p> <pre><code>...\ndependencies:\n- generics^v1.0.0\n</code></pre> <p>Tip</p> <p>The compiler version follows sementic versioning. The required version of your dependencies can be specified using npm's standard.</p>"},{"location":"install/#adding-packages","title":"Adding packages","text":"<p>The top of the atopile package registry contains a form to add packages. Add the name and the link to the git repository (GitLab or GitHub for example) and click submit. Your package should now be available to the community!</p>"},{"location":"kicad/","title":"KiCAD layout","text":""},{"location":"kicad/#kicad-installation","title":"KiCAD installation","text":"<p>To use atopile, you will need to install KiCAD. You can find it on KiCAD's official website</p>"},{"location":"kicad/#import-netlist-into-kicad","title":"Import netlist into KiCAD","text":"<p>Follow this procedure to import a netlist into KiCAD:</p> <ol> <li>File -&gt; Import Netlist </li> <li>Select the netlist you've just generated. The output is in the terminal, but it should approximately be servo-drive/build/servo-drive.net</li> <li>Make sure you're using unique IDs, rather than designators (though they should work too)</li> <li>Ruthlessly destroy stuff that's not supposed to be there (check boxes on the right) </li> <li>Check the errors - sometimes it's important</li> </ol> <p>In case you want to setup your own project, we have prepared a template with sample <code>ato</code> code and KiCAD project. Find it here.</p>"},{"location":"packages/","title":"Packages","text":"<p>Discorver existign atopile packages here: packages.atopile.io</p>"},{"location":"types/","title":"Basic types &amp; Connections","text":"<p>There's a handful of major types that you'll use in your <code>.ato</code> files, falling into two categories; blocks and nodes.</p> <p>Blocks represent something that can contain other things. They provide an abstration over their contents. For example, a block could be power supply chip and all the passive components around it.</p> <p>Nodes are elements you can connect to.</p> <p>Block types are: - <code>component</code> - represents exactly one component - <code>module</code> - a collection of components and other modules - <code>interface</code> - walks the line between a block and a node. It's a connectable block that let's you connect multiple nodes at a time</p> <p>Node types are: - <code>pin</code> - represents a physical pin/pad on a package - <code>signal</code> - represents a logical signal that can be connected to other signals</p>"},{"location":"types/#block-definition","title":"Block definition","text":""},{"location":"types/#components","title":"Components","text":"<p>Here is an example of a block (in this case a <code>component</code>) created within a file named <code>resistor.ato</code>:</p> <pre><code>component Resistor:\n    signal p1  # declare a signal named \"p1\"\n    p1 ~ pin 1  # connect that \"p1\" signal with pin 1\n    signal p2 ~ pin 2  # declare a signal named \"p2\" and connect it with pin 2 in one line\n    footprint = \"R0402\"\n</code></pre>"},{"location":"types/#footprints-for-resistors-and-capacitors","title":"Footprints for resistors and capacitors","text":"<p>For convenience, the fooprints for resistors and caps can be deinfed like so</p> Package Resistor footprint Capacitor footprint 01005 R01005 C01005 0201 R0201 C0201 0402 R0402 C0402 0603 R0603 C0603 0805 R0805 C0805 1206 C1206"},{"location":"types/#modules","title":"Modules","text":"<p>Here is an example of a <code>module</code> definition, in this case a resistor divider:</p> <pre><code>import Resistor from \"generics/resistors.ato\"\n\nmodule YourModule:\n    signal top\n    signal out\n    signal bottom\n\n    r_top = new Resistor\n    r_top.footprint = \"R0402\"\n    r_bottom = new Resistor\n    r_bottom.footprint = \"R0402\"\n\n    top ~ r_top.p1; r_top.p2 ~ out\n    out ~ r_bottom.p1; r_bottom.p2 ~ bottom\n</code></pre> <p>A module can contain an arbitrary amount of components, modules, signal and interfaces instances.</p>"},{"location":"types/#interfaces","title":"Interfaces","text":"<p>Here is an example of a <code>interface</code> definition, in this case a CAN interface</p> <pre><code>interface YourInterface:\n    signal CANH\n    signal CANL\n</code></pre> <p>An interface can contain an arbitrary amount of signals.</p> <p>Interfaces can be connected together with the <code>~</code> operator like so:</p> <pre><code>interface_1 = new YourInterface\ninterface_2 = new YourInterface\n\ninterface_1 ~ interface_2\n</code></pre> <p>Two interfaces can be connected together as long as they contain the same signals within themselves.</p>"},{"location":"types/#node-definition","title":"Node definition","text":""},{"location":"types/#signal-definition","title":"Signal definition","text":"<p>Signals can be useful as they allow you to name a connection point used throughout your design. Here is an example with a ground signal:</p> <pre><code>signal gnd\n</code></pre> <p>Signals can be connected in the following way:</p> <pre><code>signal enable_pin\nsignal vcc\nenable_pin ~ vcc\n</code></pre>"},{"location":"types/#pin-definition","title":"Pin definition","text":"<p>Pins can be defined in a similar way to signals. Pins are used specifically within components to tie your signals back to your footprints. The pin should have the same name as the copper pads in your footprint.</p> <p>Within your component, we usually recommend creating a signal and tieing it to your pin. That way you have a meaningfull signal to connect to instead of an ephemeral pin. For example:</p> <pre><code>signal vcc ~ pin 1\n</code></pre>"},{"location":"units/","title":"Units and tolerances","text":""},{"location":"units/#units","title":"Units","text":"<p>Remember how NASA slung a rocket straight into Mars because of a metric/imperial boo boo?</p> <p>How about we don't do that again.</p> <p>Resistors's resistances must be a resistance; whether <code>1.23\u03a9</code> (option+Z on OSx), <code>1.23ohm</code>, <code>4.56Kohm</code>, <code>7.89Mohm</code> or similar.</p> <p>Any attribute of any block may have a unit attached written (without a space) after any number.</p> <p>Unsurprisingly, caps capacitances need to be a capacitance; eg. <code>23.4uF</code>, various limits in volts, amperes, degrees and so on.</p> <p>Add units.</p>"},{"location":"units/#tolerances","title":"Tolerances","text":"<p>Another unfamiliar first-class language feature when dealing with the physical world is the ability (and generally requirement) to spec tolerances for attributes.</p> <p>You could try find a <code>10k\u03a9</code> resistor, but my money says you won't - it'll likely be at least <code>10k\u03a9 +/- 0.1%</code> (which you can write!)</p> <p>Tolerances can be written in the forms of: - <code>1V to 2V</code> - <code>3uF +/- 1uF</code> - <code>4Kohm +/- 1%</code></p> <p>These are hopefully sufficiently intuitive as to not warrant further explanation \ud83e\udd1e</p>"},{"location":"units/#units-and-tolerances_1","title":"Units and Tolerances","text":"<p>With Units and Tolerances together, we can define Physical attributes.</p> <p>There's quite a few legal ways to combine them!</p> <ul> <li><code>3V to 3.6V</code> perhaps for a supply rail</li> <li><code>3V +/- 10mV</code> maybe for a reference</li> <li><code>4.7uF +/- 20%</code> for a generic cap</li> <li>even <code>25lb +/- 200g</code> \ud83e\udd23</li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/01/22/hey/","title":"Hey","text":"<p>Tim here, trying out blog post. @narayan you'll want to have a look at this!</p>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/release/","title":"Release","text":""}]}